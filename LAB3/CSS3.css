/* div  :nth-child(odd){
    background: pink
    ;
}

div  :nth-child(even){
    background: red
    ;
} */

/* div :nth-child(2n+3){
    background-color: gold;
} */

/* p:nth-last-child(-n+3){
    background-color: blue;
}

p:nth-child(-n+4){
    background-color: blue;
} */

/* p :nth-child(p:nth-last-child(-n+3)){
    background-color: gold;
} */

/* p:nth-child(n+4):nth-last-child(n+3){
    background-color: gold;
    background-color: red;
    /* This is the cascaderule in which the last element is the one affecting the style */

   
/* h2{
    color: red;
} */

/* div h2{
    color: red;
} */

/* #one{
    color: red;
} */

/* .one{
    color: red;
} */

/* div>h2{
    color: red;
} */

 /* h2[class="one"]{
    color: red;
} */



/* h2[id="one"]{
    color: red;
} */

 /* h2[id^="o"]{
    color: red;
}  */

/* h2[id$="e"]{
    color: red;
}  */

/* div #one{
    color: red;
} */


/* div .one{
    color: red;
} */

/* h2#one{
    color: red;
} */

/* Specificity is one way of handling conflicts. The css code with the highest
specificity number is the one that will be applied.
h2 (by element) has Selector Specificity number = 1
.h2 (by class) has Selector Specificity number = 10
#h2 (by id) has Selector Specificity number = 100
You can use the key word !important to manually assign a code the priority. 

To handle conflicts (and also as a good designing principle):
1. Plan Ahead
2. Always use Inheritence first for basic designs in a div or table tag
3. Use Specifity with Elements and Classes (without ID) */
/* This is how you choose the google fonts */
@import url('https://fonts.googleapis.com/css2?family=Agbalumo&display=swap');

 h2{
    color: red;
    text-align: center;
    text-decoration :underline 10px #333;
    text-shadow: 4px -4px 8px red;
    text-transform:uppercase;
    font-variant:small-caps;
    writing-mode: sideways-rl;
    font-family:Agbalumo,Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif'

  
}

.two{
    text-align: justify;
    text-indent: 20px;
    line-height: 0.3in;
    letter-spacing: 5px;
    word-spacing: 10px;
    direction: rtl;
    font-size: 20 px;
    font-weight: 900;
    font-style: italic;
} 
/* Dynamic PC selectors */
/* h2#one:hover{
   text-decoration: line-through;
   color: red;
}

p:hover{
    color: green;
}

a:visited{
    color: black;
}

a:hover{
    text-shadow: 0cqmin;
    text-decoration: solid;
    color: gold;
    size: 0cqmax;
} */


/* Structural PC selectors */
/* Allows us to have more complex structural definitions on how the content
looks rather that using the DOM */

/* the below checks all the paragraph element and if it is the first child
of its parent it will give it this styling */
/* 
p:first-child{
    color: purple;
} */

/* This is one is similar to the above but makes sure that it is the first of type
child for its parent */

/* p:first-of-type{
    color: magenta;
} */

/* p:last-child{
    color: red;
} */


/* h1:only-child{
    color: red;
} */

/* h1:only-of-type{
    color: red;
} */

/* h1:first-of-type{
    color: green;
} */

/* This targets every third child starting from the second child */
/* The 2 is called the offset */
/* p:nth-child(3n+3){
    color: red;
} */

/* This means you start from the last child and go up 4 spots including last child
and since -2n is negative it will have effect in the opposite manner
that it was supposed to go meaning it will start going down instead of up */
/* p:nth-last-child(-2n+4){
    color: red;
} */

/* this targets the last three paragraphs */
/* p:nth-last-child(-n+3){
    color: red;
} */



/* p:nth-last-child(n+5){
    color: red;
} 

p:nth-child(n+8){
    color: red;
} */


/* Pseudo elements allow us even greater capabilites like targeting the first line of pargraphs 
or the first letters of paragraphs*/

/* #pseudoElements p::first-line{
    font-family: Agbalumo;
    writing-mode: sideways-rl;
}

#pseudoElements p::first-letter{
    font-size: xx-large;
    font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
    font-style: italic;
   
}

#div p::before{
    content: "Before ";
    font-weight: 700;
    font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
    font-style: italic;
}

#div p::after{
    content: "After";
    color: red;
    font-size: xx-large;
    font-weight: bolder;
}

#div p a::after{
    content: attr(href);
} */
 
/* Inheritence allows text and appearance to be inherited
by the child elements but not box appearances like padding, margin and borders*/

/* Note that even though inheritance works here the more specific the selector
it will override the parent properties if only there is overlap if there is no overlap
we have a cumulitive effect of the parent style + the child style being applied */
/* #name{
     color: red; 
    font-style: italic;
    font-family: Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif;
} */

/* #div{
    color: green;
    font-size: xx-large;
} */

/* .spanner{
    color: peru;
}
#pseudoElements p{
    color: blue;
} */
/* !!Note that eventhough this class definition is done within the paragraph it will not be applied
because the above selector has a higher specificity and also both the above and below are pointing to the same thing*/

/* #par{
    color: red;
} */

/* span#name{
    color:blueviolet ;
} */

/* Note that using the important keyword will always overide everything else
unless there is a higher specificity also using the important keyword
it is not recommended that you use the important keyword */
/* span{
    color: red !important;
} */


p{
    color: blue;
}


/* p#par{
    color: gold;
    background-color: green;
} */
#pseudoElements{
    color: red;
}
span{
    color: blueviolet;
}

